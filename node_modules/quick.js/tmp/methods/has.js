
'use strict';

/**
 * @module
 * @public
 * @requires query
 * @description compares two selections and returns only the ones that are in both
 * @param {Object} [sel] the selector to use as the comparison selection
 * @param {boolean} [doWeFilter] if true we return a new selection of overlapping els only
 * @returns {Object | boolean} boolean if not filtering, parent Object otherwise
 */
var has = function has(sel, doWeFilter) {
	var _this = this;

	var compare = this.query(sel);

	// returns true or false depending on whether or not
	// the new selection overlaps with the old selection
	var hasEl = compare.some(function (el) {
		return _this.sel.some(function (el2) {
			return el.isEqualNode(el2);
		});
	});

	// set the result to be the new selection, if filter passed in
	// only do if there is overlap, otherwise just return the existing selection
	if (hasEl && doWeFilter === 'filter') {
		(function () {
			var filtered = [];

			// compare new selection (compare) to existing selection (this[0])
			// filtered is the result of the filter, flattened (which seems unecessary but...)
			compare.forEach(function (el1) {
				return filtered.push(_this.sel.filter(function (el2) {
					return el1.isEqualNode(el2);
				}));
			});

			// this flattens the array
			filtered = [].concat.apply([], filtered);

			// set the overlap to be the new selection
			_this.sel = filtered;
		})();
	}

	// if using haz as a boolean, just return hasEl
	// if using haz as a filter then keep chaining
	return doWeFilter === 'filter' ? this : hasEl;
};

module.exports = has;